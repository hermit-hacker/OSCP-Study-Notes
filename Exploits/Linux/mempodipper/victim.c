/*
 * Sample victim process that would be exploited by the latest Linux user privilege escalation exploit
 * based on the excellent writeup and exploit code at:
 * http://blog.zx2c4.com/749
 * I have modified the mempodipper exploit code to work with this victim.
 * Basically any setuid binary that tries to dump the arguments passed to itself in stderr
 * can be exploited with stderr dup-ed to the setuid process memory overwritten with the shell code
 *
 * In order to just get a root shell exploiting /bin/su, just run after building the root_shell/mempodipper exploit
 * gcc -o root_shell root_shell.c
 * ./root_shell (gcc -o root_shell root_shell.c)
 *
 * In order to exploit this file, build this file and enable the setuid bit after changing ownership to root
 * gcc -o victim victim.c
 * sudo chown root:root victim
 * sudo chmod u+s victim
 *
 * ./root_shell -p ./victim
 * 
 * And you would have the root shell as well.
 * Another way is to get the address to exploit as the address of the exit syscall
 * to write/overlay the shell code to the process .text(code) segment.
 *
 * ./root_shell -o `objdump -d victim | grep '<exit@plt>' | head -n1 | cut -d ' ' -f1  |sed 's,^[0]*\([^0]*\),0x\1,'` -p ./victim
 */
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>
#include <limits.h>
int main(int argc, char **argv)
{
    char filename[PATH_MAX] = "/tmp/foobar";
    if(argc == 2) 
    {
        filename[0] = 0;
        strncat(filename, argv[1], sizeof(filename)-1);
    }
    if(access(filename, F_OK))
    {
        fprintf(stderr, "Unknown filename: %s\n", filename);
        exit(EXIT_FAILURE);
    }
    FILE *fptr = fopen(filename, "r");
    fclose(fptr);
    return 0;
}
